# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## CRITICAL: No Attribution

**NEVER add any attribution, signatures, or co-author tags to ANY git operations.** This includes:

- NO `Co-Authored-By` lines in commit messages
- NO Claude references in PR descriptions
- NO Claude signatures on issues or comments
- NO attribution footers of any kind
- NO "Generated by" or "Created by" tags

Commit messages should contain ONLY the commit message itself - nothing else.

## Project Overview

AgenC is a privacy-preserving AI agent coordination protocol built on Solana. It enables decentralized task coordination with zero-knowledge proofs for private task completions.

**Modules:**
- **Anchor Program** - Solana smart contract for task coordination, disputes, and rewards
- **TypeScript SDK** - Privacy-preserving task coordination client (`@agenc/sdk`)
- **Agent Runtime** - Agent lifecycle management infrastructure (`@agenc/runtime`)
- **Demo App** - React web interface for privacy workflow demonstration
- **ZK Circuits** - Circom circuits for private task completion proofs (snarkjs/Groth16)
- **Test Infrastructure** - TypeScript integration tests and Rust fuzz testing

## Quick Start

```bash
# 1. Install dependencies
npm install

# 2. Build the Anchor program
anchor build

# 3. Run integration tests (starts local validator)
anchor test

# 4. Build SDK (optional, for development)
cd sdk && npm run build
```

**Prerequisites:** Rust, Solana CLI (`v3.0.13`), Anchor CLI (`v0.32.1`), Node.js (`>=18`)

## Build Commands

### Solana Anchor Program (Rust)

```bash
# Prerequisites: solana-cli, anchor-cli
cd programs/agenc-coordination
anchor build      # Build the Solana program
anchor test       # Run tests (requires local validator)
```

### TypeScript SDK

```bash
cd sdk
npm install       # Install dependencies
npm run build     # Build SDK (outputs to dist/)
npm run typecheck # Type checking only
```

### Demo App

```bash
cd demo-app
npm install       # Install dependencies
npm run dev       # Development server
npm run build     # Production build (outputs to dist/)
```

**Build Tool:** Vite (React + TypeScript)

**6-Step Privacy Workflow:**
1. **Create Task** - Post task with escrow reward
2. **Shield Escrow** - Move funds into private pool
3. **Claim Task** - Worker claims available task
4. **Generate Proof** - Create ZK proof of completion
5. **Verify On-Chain** - Submit proof for verification
6. **Private Withdraw** - Collect reward privately

### ZK Circuits (Circom)

> **Note:** Migrated from Noir/Sunspot to Circom/snarkjs/groth16-solana (PRs #165-#169).

```bash
cd circuits/task_completion
circom src/task_completion.circom --r1cs --wasm   # Compile circuit
snarkjs groth16 prove                              # Generate proof
snarkjs groth16 verify                             # Verify proof locally
```

### Integration Tests

```bash
anchor test                           # Run all TypeScript tests
npx ts-mocha tests/smoke.ts          # Run specific test file
npx ts-mocha tests/test_1.ts         # Main test suite
```

### Fuzz Tests

```bash
cd programs/agenc-coordination
cargo fuzz run claim_task            # Fuzz claim_task instruction
cargo fuzz run complete_task         # Fuzz complete_task instruction
cargo fuzz run vote_dispute          # Fuzz vote_dispute instruction
cargo fuzz run resolve_dispute       # Fuzz resolve_dispute instruction
```

## Architecture

```
AgenC/
├── .github/                         # GitHub configuration
│   ├── workflows/ci.yml             # CI pipeline (rust_checks, anchor_build, security_scans)
│   └── dependabot.yml               # Dependency updates
├── programs/agenc-coordination/     # Solana Anchor program (Rust)
│   ├── src/
│   │   ├── lib.rs                   # Program entrypoint
│   │   ├── state.rs                 # Account structures
│   │   ├── errors.rs                # Error definitions (78 codes: 6000-6077)
│   │   ├── events.rs                # Event emissions (17 event types)
│   │   ├── instructions/            # Instruction handlers (20 instructions)
│   │   │   └── completion_helpers.rs # Shared completion logic
│   │   └── utils/                   # Multisig and version utilities
│   └── fuzz/                        # Fuzz testing
│       ├── fuzz_targets/            # claim_task, complete_task, vote_dispute, resolve_dispute
│       └── src/
│           ├── lib.rs               # Common infrastructure
│           ├── arbitrary.rs         # Property-based data generation
│           ├── invariants.rs        # Protocol invariant checking
│           ├── main.rs              # Orchestration
│           └── scenarios.rs         # Test scenarios
├── sdk/                             # TypeScript SDK (@agenc/sdk v1.2.0)
│   ├── src/
│   │   ├── index.ts                 # Main exports
│   │   ├── client.ts                # PrivacyClient class
│   │   ├── proofs.ts                # ZK proof generation/verification
│   │   ├── tasks.ts                 # Task operations
│   │   ├── privacy.ts               # Privacy Cash integration
│   │   ├── constants.ts             # Program IDs, RPC endpoints
│   │   └── types/                   # TypeScript definitions
│   │       ├── privacycash.d.ts     # Privacy Cash type stubs
│   │       └── zkpassport-poseidon2.d.ts
│   └── dist/                        # Build output (ESM + CJS)
├── runtime/                         # Agent Runtime (@agenc/runtime v0.1.0)
│   ├── src/
│   │   ├── index.ts                 # Main exports
│   │   ├── idl.ts                   # IDL + Program factory functions
│   │   ├── runtime.ts               # AgentRuntime class (lifecycle wrapper)
│   │   ├── agent/
│   │   │   ├── index.ts             # Agent module exports
│   │   │   ├── manager.ts           # AgentManager class
│   │   │   ├── events.ts            # Event subscriptions
│   │   │   ├── pda.ts               # PDA derivation helpers
│   │   │   ├── types.ts             # Agent types + capabilities
│   │   │   └── capabilities.ts      # Capability constants
│   │   ├── types/
│   │   │   ├── index.ts             # Type exports
│   │   │   ├── config.ts            # AgentRuntimeConfig + isKeypair
│   │   │   ├── errors.ts            # Error classes
│   │   │   ├── wallet.ts            # Wallet types + loaders
│   │   │   ├── protocol.ts          # Protocol config types
│   │   │   └── agenc_coordination.ts # Generated IDL types
│   │   └── utils/
│   │       ├── index.ts             # Utility exports
│   │       ├── encoding.ts          # ID/hex encoding utilities
│   │       └── logger.ts            # Logger utility
│   ├── idl/                         # Copied IDL JSON
│   └── dist/                        # Build output (ESM + CJS)
├── demo-app/                        # React + Vite web interface
│   ├── src/
│   │   ├── App.tsx                  # Main application
│   │   └── components/
│   │       └── steps/               # 6-step privacy workflow
│   │           ├── Step1CreateTask.tsx
│   │           ├── Step2ShieldEscrow.tsx
│   │           ├── Step3ClaimTask.tsx
│   │           ├── Step4GenerateProof.tsx
│   │           ├── Step5VerifyOnChain.tsx
│   │           └── Step6PrivateWithdraw.tsx
│   └── dist/                        # Production build
├── circuits/task_completion/        # Noir ZK circuits
│   ├── src/main.nr                  # Task completion proof circuit
│   ├── Nargo.toml                   # Circuit config (Noir >=0.36.0)
│   └── Prover.toml                  # Example prover inputs
├── examples/
│   ├── helius-webhook/              # Helius webhook handler
│   │   ├── index.ts
│   │   ├── package.json
│   │   └── README.md
│   └── tetsuo-integration/          # Tetsuo AI integration
│       ├── index.ts
│       ├── package.json
│       └── README.md
├── tests/                           # TypeScript test suite
│   ├── test_1.ts                    # Main integration tests
│   ├── smoke.ts                     # Devnet smoke tests
│   ├── coordination-security.ts     # Security-focused tests
│   ├── audit-high-severity.ts       # Audit issue tests
│   ├── rate-limiting.ts             # Rate limiting tests
│   ├── upgrades.ts                  # Protocol upgrade tests
│   ├── complete_task_private.ts     # ZK private completion tests
│   ├── integration.ts               # Anchor 0.32 lifecycle tests
│   └── minimal.ts                   # Minimal debugging tests
├── migrations/                      # Protocol migration tools
│   ├── migration_utils.ts           # Migration utilities
│   ├── v1_to_v2.rs                  # Version migration template
│   └── README.md
├── scripts/                         # Build/deployment scripts
│   └── simulate_upgrade.sh          # Upgrade simulation
├── audit/                           # Bug bounty & reviews
│   ├── BOUNTY_PROGRAM.md            # Bug bounty details
│   └── INTERNAL_REVIEW.md           # Internal review notes
├── docs/                            # Documentation
│   ├── DEPLOYMENT.md                # Solana deployment guide
│   ├── INTEGRATION.md               # Framework integration guide
│   ├── PRIVACY_README.md            # Privacy features documentation
│   ├── FUZZ_TESTING.md              # Fuzz testing guide
│   ├── UPGRADE_GUIDE.md             # Version upgrade guide
│   ├── MAINNET_DEPLOYMENT.md        # Mainnet deployment checklist
│   ├── NOIR_REFERENCE.md            # Noir language reference
│   ├── SECURITY_AUDIT_*.md          # Security audit documentation
│   ├── architecture.md              # Architecture overview
│   └── audit/                       # Audit documentation
│       ├── AUDIT_ROADMAP.md
│       ├── RUST_MIGRATION_ROADMAP.md
│       └── THREAT_MODEL.md
└── Anchor.toml                      # Anchor config (v0.32.1, Solana v3.0.13)
```

## TypeScript SDK

### Installation

```bash
npm install @agenc/sdk
```

### Package Configuration

- **Version:** `1.2.0`
- **Build Tool:** `tsup` (outputs ESM + CJS dual build)
- **Entry Points:** `dist/index.js` (CJS), `dist/index.mjs` (ESM)
- **Node:** `>=18.0.0`
- **Peer Dependencies:** `@coral-xyz/anchor >=0.29.0`, `@solana/web3.js >=1.90.0`

### Key Dependencies

| Package | Purpose |
|---------|---------|
| `@coral-xyz/anchor` | Anchor client |
| `@solana/web3.js` | Solana base SDK |
| `@zkpassport/poseidon2` | ZK-friendly hashing |
| `commander` | CLI framework |
| `chalk`, `ora` | CLI output formatting |

### Core Client

```typescript
import { PrivacyClient, PrivacyClientConfig } from '@agenc/sdk';
import { Connection, Keypair } from '@solana/web3.js';

const config: PrivacyClientConfig = {
  connection: new Connection('https://api.devnet.solana.com'),
  wallet: keypair,
};
const client = new PrivacyClient(config);
```

### Task Operations

```typescript
import { createTask, claimTask, completeTask, completeTaskPrivate, getTask } from '@agenc/sdk';
import { TaskParams, TaskState, TaskStatus } from '@agenc/sdk';

// Create task
const params: TaskParams = {
  taskId: 'task-123',
  reward: 1_000_000, // lamports
  constraintHash: [...],
};
await createTask(client, params);

// Claim and complete
await claimTask(client, taskId);
await completeTask(client, taskId, proofHash, resultData);

// Private completion (with ZK proof)
await completeTaskPrivate(client, taskId, proof);
```

### ZK Proof Operations

```typescript
import { generateProof, verifyProofLocally, ProofGenerationParams, ProofResult } from '@agenc/sdk';

const params: ProofGenerationParams = {
  taskId: 42n,
  agentPubkey: agent.publicKey.toBytes(),
  output: [1n, 2n, 3n, 4n],
  salt: 12345n,
};

const result: ProofResult = await generateProof(params);
const valid = await verifyProofLocally(result.proof);
```

### Constants

```typescript
import { PROGRAM_ID, VERIFIER_PROGRAM_ID, PRIVACY_CASH_PROGRAM_ID, DEVNET_RPC, MAINNET_RPC } from '@agenc/sdk';
```

### AgenCPrivacyClient

Advanced privacy client for shielded transactions:

```typescript
import { AgenCPrivacyClient } from '@agenc/sdk';

const privacyClient = new AgenCPrivacyClient(connection, wallet);

// Shield funds into privacy pool
const shieldResult = await privacyClient.shieldEscrow(creator, lamports);

// Get shielded balance
const balance = await privacyClient.getShieldedBalance();

// Complete task with private payment
const result = await privacyClient.completeTaskPrivate({
  taskPda,
  proof,
  constraintHash,
  outputCommitment,
}, worker);
```

### SDK Helper Functions

**PDA Derivation:**
```typescript
import { deriveClaimPda, deriveEscrowPda } from '@agenc/sdk';

const claimPda = deriveClaimPda(taskPda, agentPda, programId);
const escrowPda = deriveEscrowPda(taskPda, programId);
```

**Query Functions:**
```typescript
import { getTasksByCreator, formatTaskState } from '@agenc/sdk';

const tasks = await getTasksByCreator(connection, program, creatorPubkey);
const stateString = formatTaskState(TaskState.Open); // "Open"
```

**Proof Utilities:**
```typescript
import {
  generateSalt,
  computeConstraintHash,
  computeCommitment,
  pubkeyToField,
  checkToolsAvailable
} from '@agenc/sdk';

const salt = generateSalt();                           // Secure random bigint
const constraintHash = computeConstraintHash(output);  // Poseidon2 hash
const commitment = computeCommitment(hash, salt);      // Output commitment
const field = pubkeyToField(publicKey);                // Convert to BN254 field
const toolsOk = await checkToolsAvailable();           // Check snarkjs/circom
```

**Formatting:**
```typescript
// Static utilities on PrivacyClient
const solString = PrivacyClient.formatSol(1_000_000_000n); // "1.0 SOL"
const lamports = PrivacyClient.parseSol("1.5");             // 1500000000n
```

## Agent Runtime

The `@agenc/runtime` package provides high-level agent lifecycle management infrastructure for building AI agents on the AgenC protocol.

**Status:** Phase 1 COMPLETE - all 16 sections implemented and merged (tracked in [#127](https://github.com/tetsuo-ai/AgenC/issues/127))

### Package Configuration

- **Version:** `0.1.0`
- **Build Tool:** `tsup` (outputs ESM + CJS dual build)
- **Test Framework:** `vitest`
- **Node:** `>=18.0.0`
- **Peer Dependencies:** `@coral-xyz/anchor >=0.29.0`, `@solana/web3.js >=1.90.0`

### Build Commands

```bash
cd runtime
npm install       # Install dependencies
npm run build     # Build (outputs to dist/)
npm run test      # Run tests with vitest
npm run typecheck # Type checking only
```

### AgentManager Class

The core class for managing agent lifecycle:

```typescript
import { Connection, Keypair } from '@solana/web3.js';
import {
  AgentManager,
  keypairToWallet,
  generateAgentId,
  AgentCapabilities,
  AgentStatus,
  agentStatusToString,
} from '@agenc/runtime';

const connection = new Connection('https://api.devnet.solana.com');
const wallet = keypairToWallet(Keypair.generate());

const manager = new AgentManager({ connection, wallet });

// Register a new agent
const agentId = generateAgentId();
const state = await manager.register({
  agentId,
  capabilities: AgentCapabilities.COMPUTE | AgentCapabilities.INFERENCE,
  endpoint: 'https://my-agent.example.com',
  stakeAmount: 1_000_000_000n, // 1 SOL
});

// Load existing agent
await manager.load(existingAgentId);

// Update agent
await manager.updateStatus(AgentStatus.Active);
await manager.updateCapabilities(AgentCapabilities.COMPUTE | AgentCapabilities.STORAGE);
await manager.updateEndpoint('https://new-endpoint.example.com');

// Query state
const currentState = await manager.getState();
const rateLimits = await manager.getRateLimitState();

// Deregister (requires no active tasks, no pending dispute votes, 24h since last vote)
await manager.deregister();
```

### AgentRuntime Class

High-level wrapper around AgentManager with automatic lifecycle management:

```typescript
import { Connection, Keypair } from '@solana/web3.js';
import { AgentRuntime, AgentCapabilities } from '@agenc/runtime';

const runtime = new AgentRuntime({
  connection: new Connection('https://api.devnet.solana.com'),
  wallet: Keypair.generate(),
  capabilities: AgentCapabilities.COMPUTE | AgentCapabilities.INFERENCE,
  initialStake: 1_000_000_000n, // 1 SOL
  logLevel: 'info',
});

// Register shutdown handlers (optional - for graceful process termination)
runtime.registerShutdownHandlers();

// Start the runtime (registers agent if needed, sets Active status)
await runtime.start();

console.log('Agent running:', runtime.getAgentId());

// ... agent operations ...

// Stop the runtime (sets Inactive status, cleans up subscriptions)
await runtime.stop();
```

**AgentRuntimeConfig Options:**

| Option | Type | Required | Default | Description |
|--------|------|----------|---------|-------------|
| `connection` | `Connection` | Yes | — | Solana RPC connection |
| `wallet` | `Keypair \| Wallet` | Yes | — | Wallet for signing transactions |
| `programId` | `PublicKey` | No | `PROGRAM_ID` | Custom program ID |
| `agentId` | `Uint8Array` | No | Random 32 bytes | Agent ID to load/register |
| `capabilities` | `bigint` | For new agents | — | Capabilities bitmask |
| `endpoint` | `string` | No | `agent://<short_id>` | Agent network endpoint |
| `metadataUri` | `string` | No | — | Extended metadata URI |
| `initialStake` | `bigint` | No | `0n` | Initial stake in lamports |
| `logLevel` | `LogLevel` | No | Silent | `'debug' \| 'info' \| 'warn' \| 'error'` |

**Lifecycle Methods:**

| Method | Description |
|--------|-------------|
| `start()` | Check if agent exists → load or register → set Active status |
| `stop()` | Set Inactive status (graceful on failure) → unsubscribe events |
| `gracefulShutdown()` | Call stop() then exit process with code 0 |
| `registerShutdownHandlers()` | Register SIGINT/SIGTERM handlers (idempotent) |

**Query Methods:**

| Method | Description |
|--------|-------------|
| `getAgentState()` | Fetch current agent state from chain |
| `getAgentId()` | Get agent ID (returns copy to prevent mutation) |
| `getAgentPda()` | Get agent PDA address (null if not started) |
| `getAgentManager()` | Get underlying AgentManager for advanced operations |
| `isStarted()` | Check if runtime has been started |

### Protocol Config Caching

AgentManager includes intelligent caching for protocol configuration ([#150](https://github.com/tetsuo-ai/AgenC/pull/150)):

```typescript
import { AgentManager, ProtocolConfigCacheOptions } from '@agenc/runtime';

// Configure caching behavior
const manager = new AgentManager({
  connection,
  wallet,
  protocolConfigCache: {
    ttlMs: 60000,              // Cache TTL in ms (default: 300000 = 5 min)
    returnStaleOnError: true,  // Return stale data on fetch failure (default: false)
  },
});

// Normal usage (uses cache)
const config = await manager.getProtocolConfig();

// Force fresh fetch (bypasses cache)
const freshConfig = await manager.getProtocolConfig({ forceRefresh: true });

// Manual cache invalidation (e.g., after protocol update event)
manager.invalidateProtocolConfigCache();

// Synchronous cache access
const cached = manager.getCachedProtocolConfig();  // Returns null if not cached
const isFresh = manager.isProtocolConfigCacheFresh();  // Check if cache is within TTL
```

**Cache Options:**

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `ttlMs` | `number` | `300000` | Time-to-live in ms. Set to `0` to disable, `Infinity` to cache forever |
| `returnStaleOnError` | `boolean` | `false` | Return stale cached data when fetch fails |

**Implementation Features:**
- **TTL-based expiration**: Cached data expires after configured TTL
- **Promise deduplication**: Concurrent calls share single RPC request (thundering herd prevention)
- **Generation counter**: Prevents stale data from in-flight fetches after invalidation
- **Error isolation**: Failed fetches don't poison the cache

### Event Subscriptions

Subscribe to agent-related protocol events:

```typescript
import {
  subscribeToAgentRegistered,
  subscribeToAgentUpdated,
  subscribeToAgentDeregistered,
  subscribeToAllAgentEvents,
} from '@agenc/runtime';

// Subscribe to specific events
const subscription = subscribeToAgentRegistered(program, (event, slot, sig) => {
  console.log(`Agent ${bytesToHex(event.agentId)} registered at slot ${slot}`);
});

// Subscribe to all agent events
const allSub = subscribeToAllAgentEvents(program, {
  onRegistered: (event) => console.log('Registered:', event.agentId),
  onUpdated: (event) => console.log('Updated:', event.status),
  onDeregistered: (event) => console.log('Deregistered:', event.agentId),
}, { agentId: myAgentId }); // Optional: filter by agent ID

// Unsubscribe
await subscription.unsubscribe();
```

### Agent Capabilities

Bitmask constants matching the Anchor program:

```typescript
import { AgentCapabilities, hasCapability, getCapabilityNames, createCapabilityMask } from '@agenc/runtime';

// Capability constants (bigint)
AgentCapabilities.COMPUTE     // 1n << 0n
AgentCapabilities.INFERENCE   // 1n << 1n
AgentCapabilities.STORAGE     // 1n << 2n
AgentCapabilities.NETWORK     // 1n << 3n
AgentCapabilities.SENSOR      // 1n << 4n
AgentCapabilities.ACTUATOR    // 1n << 5n
AgentCapabilities.COORDINATOR // 1n << 6n
AgentCapabilities.ARBITER     // 1n << 7n
AgentCapabilities.VALIDATOR   // 1n << 8n
AgentCapabilities.AGGREGATOR  // 1n << 9n

// Helper functions
const caps = AgentCapabilities.COMPUTE | AgentCapabilities.INFERENCE;
hasCapability(caps, AgentCapabilities.COMPUTE);  // true
getCapabilityNames(caps);                         // ['COMPUTE', 'INFERENCE']
createCapabilityMask(['COMPUTE', 'STORAGE']);    // 5n
```

### PDA Derivation

```typescript
import { deriveAgentPda, deriveProtocolPda, findAgentPda, findProtocolPda } from '@agenc/runtime';

// With bump (returns { address, bump })
const { address: agentPda, bump } = deriveAgentPda(agentId, programId);

// Address only (common case)
const agentPda = findAgentPda(agentId, programId);
const protocolPda = findProtocolPda(programId);
```

### Wallet Utilities

```typescript
import {
  keypairToWallet,
  loadKeypairFromFile,
  loadDefaultKeypair,
  getDefaultKeypairPath,
} from '@agenc/runtime';

// Convert Keypair to Wallet interface
const wallet = keypairToWallet(keypair);

// Load keypair from file (async)
const keypair = await loadKeypairFromFile('/path/to/keypair.json');

// Load from default Solana CLI location (~/.config/solana/id.json)
const defaultKeypair = await loadDefaultKeypair();
```

### Encoding Utilities

```typescript
import {
  generateAgentId,
  agentIdFromString,
  agentIdToString,
  agentIdToShortString,
  agentIdsEqual,
  hexToBytes,
  bytesToHex,
  lamportsToSol,
  solToLamports,
} from '@agenc/runtime';

// Generate random 32-byte agent ID
const agentId = generateAgentId();

// String conversions
const hex = agentIdToString(agentId);       // Full 64-char hex
const short = agentIdToShortString(agentId); // "abc123...def456"
const bytes = agentIdFromString(hex);

// SOL/lamports conversion
const sol = lamportsToSol(1_000_000_000n);  // 1.0
const lamports = solToLamports(1.5);         // 1500000000n
```

### Error Classes

```typescript
import {
  RuntimeError,
  AgentNotRegisteredError,
  AgentAlreadyRegisteredError,
  ValidationError,
  InsufficientStakeError,
  ActiveTasksError,
  PendingDisputeVotesError,
  RecentVoteActivityError,
  isRuntimeError,
  RuntimeErrorCodes,
} from '@agenc/runtime';

try {
  await manager.register(params);
} catch (err) {
  if (err instanceof AgentAlreadyRegisteredError) {
    console.log('Agent already exists');
  } else if (err instanceof InsufficientStakeError) {
    console.log(`Need ${err.required} lamports, have ${err.provided}`);
  }
}
```

### Logger Utility

```typescript
import { createLogger, LogLevel, silentLogger } from '@agenc/runtime';

// LogLevel is a string type: 'debug' | 'info' | 'warn' | 'error'
const logger = createLogger('debug', '[MyAgent]');
logger.debug('Debug message');
logger.info('Info message');
logger.warn('Warning');
logger.error('Error');

// Use silent logger in production or tests
const manager = new AgentManager({ connection, wallet, logger: silentLogger });
```

### IDL and Program Factory

```typescript
import { IDL, createProgram, createReadOnlyProgram, type AgencCoordination } from '@agenc/runtime';

// Create program with wallet (for transactions)
const program = createProgram(provider, programId);

// Create read-only program (no wallet needed)
const readOnlyProgram = createReadOnlyProgram(connection, programId);
```

### Implementation Status

Phase 1 progress (tracked in [#127](https://github.com/tetsuo-ai/AgenC/issues/127)):

| Component | Issue | PR | Status |
|-----------|-------|-----|--------|
| Package Structure | #113 | #130 | ✅ Complete |
| IDL Setup | #114 | #132 | ✅ Complete |
| Error Types | #116 | #134 | ✅ Complete |
| Wallet Types | #112 | #133 | ✅ Complete |
| Protocol Types | #115 | #135 | ✅ Complete |
| Agent Types | #118 | #139 | ✅ Complete |
| Capabilities | #117 | #140 | ✅ Complete |
| Encoding Utilities | #119 | #142 | ✅ Complete |
| Logger Utility | #110 | #141 | ✅ Complete |
| PDA Helpers | #111 | #144 | ✅ Complete |
| Event Subscriptions | #126 | #144 | ✅ Complete |
| AgentManager Class | #122 | #144, #147, #150 | ✅ Complete |
| AgentRuntime Class | #125 | #153 | ✅ Complete |
| Module Exports | #121 | #177 | ✅ Complete |
| Unit Tests | #120 | #178 | ✅ Complete |
| Integration Tests | #124 | #177 | ✅ Complete |

## Zero-Knowledge Circuits

### Technology Stack

| Layer | Technology | Purpose |
|-------|------------|---------|
| Circuit | Circom | ZK circuit definition |
| Prover | snarkjs (Groth16) | Off-chain proof generation |
| Verifier | groth16-solana | On-chain proof verification |
| Hash | Poseidon2 | ZK-friendly hashing |

> **Note:** The project migrated from Noir/Sunspot to Circom/snarkjs/groth16-solana in PRs #165-#169.

**Verifier Program ID:** `8fHUGmjNzSh76r78v1rPt7BhWmAu2gXrvW9A2XXonwQQ`
**Expected Proof Size:** 388 bytes

The circuit proves task completion without revealing the output:

**Public Inputs:**
- `task_id` - Task identifier
- `agent_pubkey` - Agent's public key (32 bytes)
- `constraint_hash` - Hash of task constraints
- `output_commitment` - Commitment to output

**Private Inputs:**
- `output` - Actual task output (4 fields)
- `salt` - Randomness for commitment

**Verification:**
1. Output satisfies task constraint: `hash(output) == constraint_hash`
2. Commitment is correct: `hash(constraint_hash, salt) == output_commitment`
3. Proof is bound to task and agent

### Proof Flow

```
1. Agent computes task output locally
2. Agent generates Groth16 proof via snarkjs
3. Agent submits proof on-chain via complete_task_private
4. groth16-solana verifier CPI validates proof
5. If valid, agent receives reward without revealing output
```

## Anchor Program Instructions

| Instruction | Purpose |
|-------------|---------|
| `initialize_protocol` | Set up protocol config, treasury, fees |
| `register_agent` | Register agent with capabilities + stake |
| `deregister_agent` | Unregister agent from protocol |
| `update_agent` | Update agent capabilities |
| `create_task` | Post task with escrow reward |
| `claim_task` | Worker claims a task |
| `expire_claim` | Handle claim timeout |
| `complete_task` | Submit proof, receive payment |
| `complete_task_private` | Submit ZK proof for private completion |
| `cancel_task` | Creator cancels, gets refund |
| `update_state` | Sync shared state with version |
| `initiate_dispute` | Start dispute resolution |
| `vote_dispute` | Arbiters vote on dispute |
| `resolve_dispute` | Execute dispute resolution |
| `apply_dispute_slash` | Apply penalty for disputes |
| `expire_dispute` | Handle dispute timeout |
| `migrate` | Version migration handler |
| `update_protocol_fee` | Adjust protocol fees |
| `update_rate_limits` | Configure rate limits |

## Program Events

Events emitted for off-chain monitoring (subscribe via WebSocket):

| Event | Fields | Purpose |
|-------|--------|---------|
| `AgentRegistered` | agent_id, authority, capabilities, endpoint, timestamp | New agent joins protocol |
| `AgentUpdated` | agent_id, capabilities, status, timestamp | Agent config changed |
| `AgentDeregistered` | agent_id, authority, timestamp | Agent leaves protocol |
| `TaskCreated` | task_id, creator, required_capabilities, reward_amount, task_type, deadline, timestamp | New task posted |
| `TaskClaimed` | task_id, worker, current_workers, max_workers, timestamp | Worker claims task |
| `TaskCompleted` | task_id, worker, proof_hash, reward_paid, timestamp | Task finished |
| `TaskCancelled` | task_id, creator, refund_amount, timestamp | Task cancelled |
| `StateUpdated` | state_key, updater, version, timestamp | Shared state changed |
| `DisputeInitiated` | dispute_id, task_id, initiator, resolution_type, voting_deadline, timestamp | Dispute started |
| `DisputeVoteCast` | dispute_id, voter, approved, votes_for, votes_against, timestamp | Arbiter voted |
| `DisputeResolved` | dispute_id, resolution_type, votes_for, votes_against, timestamp | Dispute concluded |
| `DisputeExpired` | dispute_id, task_id, refund_amount, timestamp | Dispute timed out |
| `ProtocolInitialized` | authority, treasury, dispute_threshold, protocol_fee_bps, timestamp | Protocol setup |
| `RewardDistributed` | task_id, recipient, amount, protocol_fee, timestamp | Payment sent |
| `RateLimitHit` | agent_id, action_type, limit_type, current_count, max_count, cooldown_remaining, timestamp | Rate limit triggered |
| `MigrationCompleted` | from_version, to_version, authority, timestamp | Version migration done |
| `ProtocolVersionUpdated` | old_version, new_version, min_supported_version, timestamp | Protocol upgraded |

**Event name format in TypeScript:** Use camelCase (e.g., `taskCompleted`, not `TaskCompleted`)

## Code Style

- **Rust**: Anchor framework conventions
- **TypeScript**: Strict mode, ESM and CJS dual builds

### Naming Conventions

| Language | Type | Convention | Example |
|----------|------|------------|---------|
| Rust | Types | `PascalCase` | `AgentRegistration`, `TaskStatus` |
| Rust | Functions | `snake_case` | `register_agent`, `complete_task` |
| TypeScript | Types | `PascalCase` | `PrivacyClient`, `TaskParams` |
| TypeScript | Functions | `camelCase` | `generateProof`, `createTask` |

## Error Handling

### Anchor Program (CoordinationError)

Error codes are sequential from 6000-6078 (79 total). Organized by category:

```rust
// Agent errors (6000-6008)
AgentAlreadyRegistered      // 6000 - Agent already exists
AgentNotFound               // 6001 - Agent doesn't exist
AgentNotActive              // 6002 - Agent is not active
InsufficientCapabilities    // 6003 - Missing required capabilities
MaxActiveTasksReached       // 6004 - At task limit
AgentHasActiveTasks         // 6005 - Can't deregister with active tasks
UnauthorizedAgent           // 6006 - Signer doesn't own agent
AgentRegistrationRequired   // 6007 - Must register to create tasks
AgentSuspended              // 6008 - Agent is suspended, cannot change status

// Task errors (6009-6024)
TaskNotFound                // 6009 - Task doesn't exist
TaskNotOpen                 // 6010 - Task not accepting claims
TaskFullyClaimed            // 6011 - Max workers reached
TaskExpired                 // 6012 - Past deadline
TaskNotExpired              // 6013 - Deadline hasn't passed
DeadlinePassed              // 6014 - Deadline has passed
TaskNotInProgress           // 6015 - Wrong task state
TaskAlreadyCompleted        // 6016 - Task already done
TaskCannotBeCancelled       // 6017 - Task in wrong state
UnauthorizedTaskAction      // 6018 - Not task creator
InvalidCreator              // 6019 - Invalid creator
InvalidTaskType             // 6020 - Invalid task type
CompetitiveTaskAlreadyWon   // 6021 - Someone else completed first
NoWorkers                   // 6022 - Task has no workers
ConstraintHashMismatch      // 6023 - ZK proof constraint doesn't match
NotPrivateTask              // 6024 - Task has no constraint_hash

// Claim errors (6025-6033)
AlreadyClaimed              // 6025 - Worker already claimed
NotClaimed                  // 6026 - Worker hasn't claimed
ClaimAlreadyCompleted       // 6027 - Can't complete twice
ClaimNotExpired             // 6028 - Claim hasn't expired
InvalidProof                // 6029 - Invalid proof of work
ZkVerificationFailed        // 6030 - ZK proof invalid
InvalidProofSize            // 6031 - Proof not 388 bytes
InvalidProofBinding         // 6032 - Binding cannot be zeros
InvalidOutputCommitment     // 6033 - Commitment cannot be zeros

// Dispute errors (6034-6048)
DisputeNotActive            // 6034 - Dispute already resolved
VotingEnded                 // 6035 - Past voting deadline
VotingNotEnded              // 6036 - Voting still active
AlreadyVoted                // 6037 - Arbiter voted already
NotArbiter                  // 6038 - Missing ARBITER capability
InsufficientVotes           // 6039 - Not enough votes
DisputeAlreadyResolved      // 6040 - Already resolved
UnauthorizedResolver        // 6041 - Not authority/initiator
ActiveDisputeVotes          // 6042 - Has pending votes
RecentVoteActivity          // 6043 - Must wait 24h after voting
InsufficientEvidence        // 6044 - Evidence too short
EvidenceTooLong             // 6045 - Evidence exceeds max
DisputeNotExpired           // 6046 - Dispute hasn't expired
SlashAlreadyApplied         // 6047 - Slash already done
DisputeNotResolved          // 6048 - Not resolved yet

// State errors (6049-6051)
VersionMismatch             // 6049 - Concurrent modification
StateKeyExists              // 6050 - Key already exists
StateNotFound               // 6051 - State not found

// Protocol errors (6052-6062)
ProtocolAlreadyInitialized  // 6052 - Already initialized
ProtocolNotInitialized      // 6053 - Not initialized
InvalidProtocolFee          // 6054 - Fee > 1000 bps
InvalidDisputeThreshold     // 6055 - Bad threshold
InsufficientStake           // 6056 - Not enough stake for arbiter
MultisigInvalidThreshold    // 6057 - Bad multisig threshold
MultisigInvalidSigners      // 6058 - Bad signer config
MultisigNotEnoughSigners    // 6059 - Below threshold
MultisigDuplicateSigner     // 6060 - Duplicate signer
MultisigDefaultSigner       // 6061 - Zero pubkey signer
MultisigSignerNotSystemOwned // 6062 - Not system owned

// General errors (6063-6069)
InvalidInput                // 6063 - Bad parameter
ArithmeticOverflow          // 6064 - Math overflow
VoteOverflow                // 6065 - Vote count overflow
InsufficientFunds           // 6066 - Not enough lamports
CorruptedData               // 6067 - Account data corrupted
StringTooLong               // 6068 - String exceeds max
InvalidAccountOwner         // 6069 - Account not owned by program

// Rate limiting errors (6070-6072)
RateLimitExceeded           // 6070 - 24h limit reached
CooldownNotElapsed          // 6071 - Too soon since last action
InsufficientStakeForDispute // 6072 - Not enough stake for dispute

// Version/upgrade errors (6073-6078)
VersionMismatchProtocol     // 6073 - Protocol version incompatible
AccountVersionTooOld        // 6074 - Needs migration
AccountVersionTooNew        // 6075 - Needs program upgrade
InvalidMigrationSource      // 6076 - Bad source version
InvalidMigrationTarget      // 6077 - Bad target version
UnauthorizedUpgrade         // 6078 - Not upgrade authority
```

## Key Design Patterns

### PDA Seeds (Anchor)

```rust
// Protocol config (singleton)
["protocol"]

// Agent registration
["agent", agent_id]              // agent_id: [u8; 32]

// Task and related accounts
["task", creator, task_id]       // creator: Pubkey, task_id: [u8; 32]
["escrow", task_pda]             // task_pda: Pubkey
["claim", task_pda, worker_pda]  // task_pda: Pubkey, worker_pda: Pubkey

// Disputes
["dispute", dispute_id]          // dispute_id: [u8; 32]
["vote", dispute_pda, voter]     // dispute_pda: Pubkey, voter: Pubkey

// Shared state (for coordination)
["state", key]                   // key: String
```

## Configuration

### Agent Capabilities (Bitmask)

```rust
COMPUTE     = 1 << 0   // General computation
INFERENCE   = 1 << 1   // ML inference
STORAGE     = 1 << 2   // Data storage
NETWORK     = 1 << 3   // Network relay
SENSOR      = 1 << 4   // Sensor data collection
ACTUATOR    = 1 << 5   // Physical actuation
COORDINATOR = 1 << 6   // Task coordination
ARBITER     = 1 << 7   // Dispute arbitration
VALIDATOR   = 1 << 8   // Result validation
AGGREGATOR  = 1 << 9   // Data aggregation
```

### Task Types

```rust
Exclusive     // Single worker claims
Collaborative // Multiple workers contribute
Competitive   // First completion wins
```

### Protocol Constants

```rust
CURRENT_PROTOCOL_VERSION = 1
MIN_SUPPORTED_VERSION = 1
MAX_MULTISIG_OWNERS = 5
HASH_SIZE = 32              // bytes
RESULT_DATA_SIZE = 64       // bytes
```

### Size Constants (SDK)

```typescript
HASH_SIZE = 32              // Cryptographic hash size
RESULT_DATA_SIZE = 64       // Result/description fields
DISCRIMINATOR_SIZE = 8      // Anchor account discriminator
OUTPUT_FIELD_COUNT = 4      // ZK circuit output array size
PROOF_SIZE_BYTES = 388      // Groth16 proof size
PUBLIC_INPUTS_COUNT = 67    // Circuit public inputs
VERIFICATION_COMPUTE_UNITS = 50_000
```

### Account Status Enums

```rust
// AgentStatus
Inactive = 0, Active = 1, Busy = 2, Suspended = 3

// TaskStatus
Open = 0, InProgress = 1, PendingValidation = 2, Completed = 3, Cancelled = 4, Disputed = 5

// ResolutionType (disputes)
Refund = 0, Complete = 1, Split = 2

// DisputeStatus
Active = 0, Resolved = 1, Expired = 2
```

### ProtocolConfig Account

Key fields in the protocol configuration:

| Field | Type | Purpose |
|-------|------|---------|
| `authority` | Pubkey | Protocol authority |
| `treasury` | Pubkey | Fee destination |
| `protocol_fee_bps` | u16 | Fee in basis points (1/100%) |
| `dispute_threshold` | u8 | Min votes % to resolve dispute |
| `min_agent_stake` | u64 | Minimum stake to register |
| `min_arbiter_stake` | u64 | Minimum stake for arbiter role |
| `max_claim_duration` | i64 | Seconds before claim expires |
| `max_dispute_duration` | i64 | Seconds before dispute expires |
| `task_creation_cooldown` | i64 | Seconds between task creations |
| `max_tasks_per_24h` | u8 | Task rate limit (0=unlimited) |
| `dispute_initiation_cooldown` | i64 | Seconds between disputes |
| `max_disputes_per_24h` | u8 | Dispute rate limit |
| `min_stake_for_dispute` | u64 | Griefing resistance stake |
| `slash_percentage` | u8 | Stake slashed on losing (0-100) |
| `protocol_version` | u8 | Current version |
| `min_supported_version` | u8 | Backward compat version |
| `multisig_threshold` | u8 | Required multisig signers |
| `multisig_owners` | [Pubkey; 5] | Multisig owner list |

### AgentRegistration Rate Limiting

Agents track their own rate limiting state:

| Field | Type | Purpose |
|-------|------|---------|
| `last_task_created` | i64 | Timestamp of last task creation |
| `task_count_24h` | u8 | Tasks created in current window |
| `last_dispute_initiated` | i64 | Timestamp of last dispute |
| `dispute_count_24h` | u8 | Disputes in current window |
| `rate_limit_window_start` | i64 | Start of 24h window |

## Testing

### TypeScript Integration Tests

Located in `tests/`:

| File | Purpose |
|------|---------|
| `test_1.ts` | Main integration test suite |
| `smoke.ts` | Devnet smoke tests |
| `coordination-security.ts` | Security-focused tests |
| `audit-high-severity.ts` | Tests for audit findings |
| `rate-limiting.ts` | Rate limiting behavior tests |
| `upgrades.ts` | Protocol upgrade tests |
| `complete_task_private.ts` | ZK private completion tests |
| `integration.ts` | Anchor 0.32 lifecycle tests |
| `minimal.ts` | Minimal debugging tests |

### Fuzz Testing

Located in `programs/agenc-coordination/fuzz/`:

**Fuzz Targets:**

| Target | Tests |
|--------|-------|
| `claim_task` | Task claiming edge cases |
| `complete_task` | Task completion scenarios |
| `vote_dispute` | Dispute voting logic |
| `resolve_dispute` | Dispute resolution |

**Fuzz Infrastructure:**

| File | Purpose |
|------|---------|
| `src/lib.rs` | Common fuzzing infrastructure |
| `src/arbitrary.rs` | Property-based test data generation |
| `src/invariants.rs` | Protocol invariant checking |
| `src/main.rs` | Fuzz orchestration |
| `src/scenarios.rs` | Test scenario definitions |

The fuzz testing infrastructure includes comprehensive invariant checking to ensure protocol safety properties are maintained under arbitrary inputs.

### Test Patterns

**Run ID Isolation:**
```typescript
// Each test uses unique IDs to avoid state conflicts with persisted validator
const runId = `test-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
const taskId = makeId(`task-${runId}`);
```

**Direct PDA Generation:**
```typescript
const [taskPda] = PublicKey.findProgramAddressSync(
  [Buffer.from('task'), creator.toBuffer(), taskIdBuffer],
  program.programId
);
```

**Dispute Evidence Requirement:**
Minimum 50 characters for dispute evidence strings.

## Documentation Index

| Document | Description |
|----------|-------------|
| `docs/DEPLOYMENT.md` | Solana deployment guide |
| `docs/DEPLOYMENT_PLAN.md` | Deployment planning checklist |
| `docs/PRIVACY_README.md` | Privacy features documentation |
| `docs/FUZZ_TESTING.md` | Fuzz testing guide |
| `docs/UPGRADE_GUIDE.md` | Version upgrade instructions |
| `docs/MAINNET_DEPLOYMENT.md` | Mainnet deployment checklist |
| `docs/MAINNET_MIGRATION.md` | Mainnet migration guide |
| `docs/architecture.md` | Architecture overview |
| `docs/NOIR_REFERENCE.md` | Noir language reference for ZK circuits |
| `docs/STATIC_ANALYSIS.md` | Static analysis tooling |
| `docs/DEVNET_VALIDATION.md` | Devnet validation steps |
| `docs/EVENTS_OBSERVABILITY.md` | Event monitoring guide |
| `docs/SMOKE_TESTS.md` | Smoke test documentation |
| `docs/SECURITY_AUDIT_DEVNET.md` | Devnet security audit |
| `docs/SECURITY_AUDIT_MAINNET.md` | Mainnet security audit |
| `docs/audit/THREAT_MODEL.md` | Security threat model |
| `docs/audit/AUDIT_ROADMAP.md` | Audit roadmap |
| `docs/audit/RUST_MIGRATION_ROADMAP.md` | Rust migration plan |
| `audit/BOUNTY_PROGRAM.md` | Bug bounty program details |
| `sdk/README.md` | SDK usage documentation |
| `migrations/README.md` | Migration tooling guide |

## CI/CD Pipeline

GitHub Actions workflow (`.github/workflows/ci.yml`) runs on push and PR:

| Job | Purpose |
|-----|---------|
| `rust_checks` | cargo fmt, clippy, and unit tests |
| `anchor_build` | Build program + IDL, run integration tests |
| `security_scans` | cargo-audit and cargo-deny checks |

**Environment versions in CI:**
- Solana: `v3.0.13`
- Anchor: `0.32.1`
- Rust: `stable`
- Node: `20`

**Build strategy:** Two-step build to handle Rust version mismatch:
1. `cargo build-sbf` - Direct BPF compilation
2. `anchor idl build` - IDL generation with `--lib` flag

## Build Scripts

| Script | Purpose |
|--------|---------|
| `scripts/simulate_upgrade.sh` | Protocol upgrade simulation |
| `scripts/deploy-verifier.sh` | Deploy ZK verifier to Solana |

## Examples

Integration examples in `examples/`:

### Helius Webhook (`examples/helius-webhook/`)

Webhook handler for processing AgenC events via Helius:

```bash
cd examples/helius-webhook
npm install
# Set HELIUS_API_KEY in environment
npm start
```

### Tetsuo Integration (`examples/tetsuo-integration/`)

Example integration with Tetsuo AI framework:

```bash
cd examples/tetsuo-integration
npm install
npx ts-node index.ts
```

Both examples include README files with detailed setup instructions.

## Migration Utilities

TypeScript utilities in `migrations/migration_utils.ts` for protocol upgrades:

```typescript
import {
  getProtocolVersion,
  isMigrationNeeded,
  migrateProtocol,
  verifyMigration,
  getMigrationStatus,
  printMigrationStatus,
  MigrationError
} from './migrations/migration_utils';

// Check current version
const version = await getProtocolVersion(program, protocolPda);

// Check if migration needed
const needed = await isMigrationNeeded(program, protocolPda, targetVersion);

// Execute migration (requires multisig signers)
await migrateProtocol(program, protocolPda, targetVersion, multisigSigners);

// Verify migration succeeded
await verifyMigration(program, protocolPda, expectedVersion);

// Get detailed status
const status = await getMigrationStatus(program, protocolPda, programVersion);
printMigrationStatus(status);
```

**Version Utilities (Rust):**
- `check_version_compatible(config)` - Validate protocol version
- `get_version_status(config)` - Returns `VersionStatus` enum: `Current`, `CompatibleOld`, `TooOld`, `TooNew`

## Anchor Configuration

`Anchor.toml` configuration:

```toml
[toolchain]
anchor_version = "0.32.1"
solana_version = "3.0.13"

[test]
startup_wait = 60000    # Validator startup timeout (ms)
shutdown_wait = 5000    # Validator shutdown timeout (ms)

[programs.localnet]
agenc_coordination = "EopUaCV2svxj9j4hd7KjbrWfdjkspmm2BCBe7jGpKzKZ"

[programs.devnet]
agenc_coordination = "EopUaCV2svxj9j4hd7KjbrWfdjkspmm2BCBe7jGpKzKZ"
```

**Key settings:**
- `startup_wait = 60000` - Increased timeout for validator startup (default would fail on slower machines)
- Test script targets `tests/test_1.ts` specifically
- APR registry: `https://api.apr.dev`

## Deployment

See `docs/DEPLOYMENT.md` for full Solana deployment guide.

```bash
# Devnet deployment
solana config set --url devnet
anchor deploy

# Update program ID in lib.rs after deployment
declare_id!("YOUR_ACTUAL_PROGRAM_ID");
```

## Thread Safety

- Anchor programs are single-threaded per transaction
- Account locking prevents concurrent modifications to the same accounts
- Use optimistic locking for shared state updates

## Multisig Utilities

The protocol supports multisig governance via `programs/.../src/utils/multisig.rs`:

```rust
// Validate multisig owner list
validate_multisig_owners(owners)?;

// Require threshold signers for protected operations
require_multisig(config, remaining_accounts)?;
```

**Multisig Errors:**
- `MultisigDefaultSigner` - Owner is default/zero pubkey
- `MultisigDuplicateSigner` - Duplicate owner in list
- `MultisigInvalidSigners` - Signers not in owner list
- `MultisigInvalidThreshold` - Threshold > owner count
- `MultisigNotEnoughSigners` - Below threshold

## Security Patterns

### Critical Invariants

These invariants MUST be maintained across all code changes:

| Invariant | Location | Description |
|-----------|----------|-------------|
| Competitive task single-completion | `complete_task.rs`, `complete_task_private.rs` | Competitive tasks (`TaskType::Competitive`) must check `task.completions == 0` before paying rewards |
| Account owner validation | `resolve_dispute.rs` | Always validate `account.owner == crate::ID` before deserializing accounts from `remaining_accounts` |
| Constraint hash binding | `complete_task_private.rs` | ZK proofs must verify `proof.constraint_hash == task.constraint_hash` |
| Rate limit enforcement | `create_task.rs`, `initiate_dispute.rs` | Check cooldown and 24h limits before state-changing operations |

### Anchor Security Best Practices

```rust
// ALWAYS validate remaining_accounts ownership before deserialization
require!(
    account_info.owner == &crate::ID,
    CoordinationError::InvalidAccountOwner
);

// ALWAYS use checked arithmetic, NOT saturating
let result = a.checked_add(b).ok_or(CoordinationError::ArithmeticOverflow)?;

// NEVER use saturating_add/sub in production code (masks overflows)
// let result = a.saturating_add(b);  // BAD - hides errors

// ALWAYS check task type before reward distribution
if task.task_type == TaskType::Competitive {
    require!(task.completions == 0, CoordinationError::CompetitiveTaskAlreadyWon);
}
```

### SDK Cryptographic Functions

The SDK implements ZK-compatible cryptographic functions using `@zkpassport/poseidon2`:

| Function | File | Description |
|----------|------|-------------|
| `computeConstraintHash` | `proofs.ts` | Poseidon2 hash of 4-element output array |
| `computeCommitment` | `proofs.ts` | Poseidon2 hash of (constraintHash, salt) |
| `computeConstraintHashBuffer` | `proofs.ts` | Returns constraint hash as 32-byte Buffer |
| `computeOutputCommitment` | `proofs.ts` | Returns commitment as 32-byte Buffer |
| `generateSalt` | `proofs.ts` | Cryptographically secure random salt generation |

These functions use `@zkpassport/poseidon2` which is compatible with the Circom circuit's Poseidon2 implementation, ensuring hash values match between the SDK and the ZK circuit.

### Path Traversal Prevention

When accepting file paths (e.g., `circuitPath` in proof generation):

```typescript
// Validate paths to prevent directory traversal
if (circuitPath.includes('..') || path.isAbsolute(circuitPath)) {
    throw new Error('Invalid circuit path');
}
```

### Command Injection Prevention

The SDK validates circuit paths to prevent shell metacharacter injection:

```typescript
// In privacy.ts validateCircuitPath()
const dangerousChars = /[;&|`$(){}[\]<>!]/;
if (dangerousChars.test(circuitPath)) {
    throw new Error('Invalid characters in circuit path');
}
```

### Type Safety

SDK includes TypeScript type stubs for external dependencies:
- `sdk/src/types/privacycash.d.ts` - Privacy Cash SDK types
- `sdk/src/types/zkpassport-poseidon2.d.ts` - Poseidon2 hash types

## Common Pitfalls

### Anchor 0.32 Compatibility

Test files must use these patterns for Anchor 0.32:

```typescript
// Use .accountsPartial() instead of .accounts() for optional accounts
await program.methods
    .resolveDispute()
    .accountsPartial({
        worker: null,           // Optional account
        workerClaim: null,      // Optional account
    })
    .rpc();

// Event names are camelCase, not PascalCase
const events = await program.addEventListener('taskCompleted', callback);
// NOT: 'TaskCompleted'
```

### Anchor IDL Type Handling (CRITICAL)

Anchor generates two files with **different naming conventions**:

| File | Location | Naming | Purpose |
|------|----------|--------|---------|
| `agenc_coordination.json` | `target/idl/` | snake_case | Runtime IDL data |
| `agenc_coordination.ts` | `target/types/` | camelCase | TypeScript type helper |

The TypeScript file explicitly states: *"This is only a type helper and is not the actual IDL."*

**WRONG - Types lie about the structure:**
```typescript
import type { AgencCoordination } from './types/agenc_coordination';
import idlJson from '../idl/agenc_coordination.json';

// BAD: AgencCoordination uses camelCase but JSON has snake_case
export const IDL = idlJson as AgencCoordination;

// TypeScript thinks: IDL.metadata.name === "agencCoordination"
// Runtime reality: IDL.metadata.name === "agenc_coordination"
```

**CORRECT - Use Anchor's generic `Idl` type for raw JSON:**
```typescript
import { Idl, Program, AnchorProvider } from '@coral-xyz/anchor';
import type { AgencCoordination } from './types/agenc_coordination';
import idlJson from '../idl/agenc_coordination.json';

// GOOD: Idl type correctly represents snake_case JSON structure
export const IDL: Idl = idlJson as Idl;

// Re-export the type for Program generics
export type { AgencCoordination };

// Factory functions return type-safe Program instances
export function createProgram(
  provider: AnchorProvider,
  programId?: PublicKey
): Program<AgencCoordination> {
  // Anchor's Program class handles snake_case ↔ camelCase mapping internally
  const idl = programId ? { ...IDL, address: programId.toBase58() } : IDL;
  return new Program<AgencCoordination>(idl as AgencCoordination, provider);
}
```

**Key points:**
- Export raw IDL typed as `Idl` (generic) - accurate for JSON structure
- Export `AgencCoordination` type for `Program<T>` generic parameter
- Anchor's `Program` class handles snake_case → camelCase mapping automatically
- Users call `program.methods.createTask()` (camelCase) and Anchor maps to `"create_task"` in IDL
- In Anchor 0.30+, Program constructor is 2 args: `new Program(idl, provider)` - programId comes from `idl.address`
- To override programId, modify `idl.address` before constructing

### Test Logic Errors

```typescript
// WRONG: Modifying local copy has no on-chain effect
const agent = await program.account.agentRegistration.fetch(agentPda);
agent.activeTasks = 10;  // This only changes local JS object!

// RIGHT: Use program instructions to modify on-chain state
await program.methods.updateAgent(...).rpc();
```

### Keypair Reuse in Tests

```typescript
// WRONG: Creating new keypair loses authority
const worker = Keypair.generate();  // in before()
// ... later in test ...
const worker = Keypair.generate();  // DIFFERENT keypair!

// RIGHT: Store and reuse keypairs
let workerKeypair: Keypair;
before(() => { workerKeypair = Keypair.generate(); });
// ... use workerKeypair throughout ...
```

## Environment Variables

| Variable | Used In | Purpose |
|----------|---------|---------|
| `VITE_SOLANA_RPC_URL` | demo-app | Custom RPC endpoint (defaults to devnet) |
| `HELIUS_API_KEY` | examples/helius-webhook | Helius API authentication |
| `NODE_ENV` | sdk | When `production`, SDK placeholder functions throw errors |

## Security Audit Checklist

When modifying instruction handlers, verify:

- [ ] Account ownership validated for `remaining_accounts`
- [ ] Competitive task completion check present
- [ ] Arithmetic uses `checked_*` operations
- [ ] Rate limits enforced where applicable
- [ ] Events emitted for state changes
- [ ] PDA seeds match expected format
- [ ] Signer constraints properly applied
- [ ] Version compatibility checked
