//! Private task completion with ZK proof verification.
//!
//! Enables agents to prove task completion without revealing outputs.
//! Uses inline Groth16 verification via groth16-solana (audited by OtterSec, Neodyme, Zellic).
//!
//! # Security Model
//!
//! ## Proof Binding (Anti-Replay Protection)
//!
//! The ZK circuit enforces cryptographic binding of each proof to a specific
//! (task_id, agent_pubkey, output_commitment) tuple. This prevents:
//!
//! 1. **Cross-task replay**: A proof for task A cannot be used for task B
//! 2. **Cross-agent theft**: A proof generated by agent A cannot be used by agent B
//! 3. **Output reuse**: Each (task, agent) pair requires a unique commitment
//!
//! The binding is computed as: `hash(hash(task_id, agent_pubkey), output_commitment)`
//! and is verified as a public input to the circuit.
//!
//! ## Nullifier Mechanism (Proof/Knowledge Reuse Prevention - fix: issue #336)
//!
//! The nullifier prevents an agent from reusing the same proof/knowledge across
//! different tasks. The circuit computes: `nullifier = Poseidon(constraint_hash, agent_secret)`
//!
//! - The agent_secret is a private input known only to the agent
//! - Each unique (constraint, agent_secret) pair produces a unique nullifier
//! - The on-chain program stores spent nullifiers as PDAs
//! - If a nullifier PDA already exists, the transaction is rejected
//!
//! This ensures that if two tasks have the same constraint_hash (expecting the same
//! output), an agent cannot simply reuse a proof from one task to complete the other.
//!
//! ## Defense-in-Depth (fix: issue #88)
//!
//! On-chain validation provides multiple layers of protection:
//!
//! 1. The public witness is built from actual on-chain accounts (task PDA, worker authority)
//! 2. Sanity checks reject all-zeros binding and commitment values
//! 3. Constraint hash must match the task's stored value
//! 4. The Groth16 verifier validates the complete proof against all public inputs
//!
//! If an attacker tries to submit a proof generated for different accounts,
//! the witness mismatch causes ZK verification to fail.
//!
//! # Public Witness Encoding
//!
//! The witness format matches Circom's public input encoding:
//! - Each byte of task_id and agent_pubkey becomes a separate field element
//! - Field elements are 32 bytes big-endian (BN254 scalar field)
//! - Total: 32 (task bytes) + 32 (agent bytes) + 4 (hashes including nullifier) = 68 public inputs

use crate::errors::CoordinationError;
use crate::instructions::completion_helpers::{
    calculate_fee_with_reputation, execute_completion_rewards, validate_completion_prereqs,
    validate_task_dependency,
};
use crate::instructions::constants::{
    ZK_EXPECTED_PROOF_SIZE, ZK_PROOF_A_SIZE, ZK_PROOF_B_SIZE, ZK_PROOF_C_SIZE,
    ZK_WITNESS_FIELD_COUNT,
};
use crate::state::{
    AgentRegistration, Nullifier, ProtocolConfig, Task, TaskClaim, TaskEscrow, TaskStatus,
    HASH_SIZE, RESULT_DATA_SIZE,
};
use crate::utils::compute_budget::log_compute_units;
use crate::utils::version::check_version_compatible;
use crate::verifying_key::get_verifying_key;
use anchor_lang::prelude::*;
use groth16_solana::groth16::Groth16Verifier;

// Semantic alias: field element size matches hash size
const FIELD_SIZE: usize = HASH_SIZE;

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct PrivateCompletionProof {
    pub proof_data: Vec<u8>,
    pub constraint_hash: [u8; HASH_SIZE],
    pub output_commitment: [u8; HASH_SIZE],
    pub expected_binding: [u8; HASH_SIZE],
    /// Nullifier to prevent proof/knowledge reuse across tasks.
    /// Derived in the ZK circuit as: Poseidon(constraint_hash, agent_secret)
    pub nullifier: [u8; HASH_SIZE],
}

/// Note: Large accounts use Box<Account<...>> to avoid stack overflow
/// Consistent with Anchor best practices for accounts > 10KB
#[derive(Accounts)]
#[instruction(task_id: u64, proof: PrivateCompletionProof)]
pub struct CompleteTaskPrivate<'info> {
    #[account(
        mut,
        seeds = [b"task", task.creator.as_ref(), task.task_id.as_ref()],
        bump = task.bump
    )]
    pub task: Box<Account<'info, Task>>,

    #[account(
        mut,
        close = authority,
        seeds = [b"claim", task.key().as_ref(), worker.key().as_ref()],
        bump = claim.bump,
        constraint = claim.task == task.key() @ CoordinationError::NotClaimed
    )]
    pub claim: Box<Account<'info, TaskClaim>>,

    /// Note: Escrow account is closed conditionally after the final completion.
    /// For collaborative tasks with multiple workers, it stays open until all complete.
    #[account(
        mut,
        seeds = [b"escrow", task.key().as_ref()],
        bump = escrow.bump
    )]
    pub escrow: Box<Account<'info, TaskEscrow>>,

    /// CHECK: Task creator receives escrow rent - validated to match task.creator
    #[account(
        mut,
        constraint = creator.key() == task.creator @ CoordinationError::InvalidCreator
    )]
    pub creator: UncheckedAccount<'info>,

    #[account(
        mut,
        seeds = [b"agent", worker.agent_id.as_ref()],
        bump = worker.bump,
        has_one = authority @ CoordinationError::UnauthorizedAgent
    )]
    pub worker: Box<Account<'info, AgentRegistration>>,

    #[account(
        mut,
        seeds = [b"protocol"],
        bump = protocol_config.bump
    )]
    pub protocol_config: Box<Account<'info, ProtocolConfig>>,

    /// Nullifier account to prevent proof/knowledge reuse.
    /// If this account already exists, the proof has been used before.
    #[account(
        init,
        payer = authority,
        space = Nullifier::SIZE,
        seeds = [b"nullifier", proof.nullifier.as_ref()],
        bump
    )]
    pub nullifier_account: Account<'info, Nullifier>,

    /// CHECK: Treasury account for protocol fees
    #[account(
        mut,
        constraint = treasury.key() == protocol_config.treasury @ CoordinationError::InvalidInput
    )]
    pub treasury: UncheckedAccount<'info>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}

/// Complete a task with private ZK proof verification.
///
/// # Arguments
/// * `task_id` - The task ID, validated against the task account for safety
/// * `proof` - The ZK proof containing proof_data, constraint_hash, output_commitment, expected_binding, and nullifier
pub fn complete_task_private(
    ctx: Context<CompleteTaskPrivate>,
    task_id: u64,
    proof: PrivateCompletionProof,
) -> Result<()> {
    let task = &mut ctx.accounts.task;
    let claim = &mut ctx.accounts.claim;
    let escrow = &mut ctx.accounts.escrow;
    let worker = &mut ctx.accounts.worker;
    let nullifier_account = &mut ctx.accounts.nullifier_account;
    let clock = Clock::get()?;

    // Validate provided task_id matches the task account (fix: issue #406)
    // This prevents callers from accidentally passing the wrong task_id
    require!(
        task_id == u64::from_le_bytes(task.task_id[..8].try_into().expect("task_id slice is always 8 bytes")),
        CoordinationError::TaskNotFound
    );

    // Deadline check (issue #384) â€” explicit check before shared prereqs preserves ordering
    require!(
        task.deadline == 0 || clock.unix_timestamp <= task.deadline,
        CoordinationError::DeadlinePassed
    );

    check_version_compatible(&ctx.accounts.protocol_config)?;

    // If task has a proof dependency, verify parent task is completed (fix: issue #832)
    validate_task_dependency(task, ctx.remaining_accounts, ctx.program_id)?;

    // Shared validation: status, transition, deadline (redundant but harmless), claim, competitive guard
    validate_completion_prereqs(task, claim, &clock)?;

    // CRITICAL: Verify this is a private task (has a non-zero constraint_hash)
    // Tasks without constraint_hash should use complete_task, not complete_task_private
    require!(
        task.constraint_hash != [0u8; HASH_SIZE],
        CoordinationError::NotPrivateTask
    );

    // CRITICAL: Verify the proof's constraint_hash matches the task's stored constraint_hash
    // This prevents attackers from proving an arbitrary constraint they can satisfy
    require!(
        proof.constraint_hash == task.constraint_hash,
        CoordinationError::ConstraintHashMismatch
    );

    // CRITICAL: Defense-in-depth validation for proof binding (fix: issue #88)
    // The circuit enforces binding = hash(hash(task_id, agent), output_commitment)
    // These checks catch malformed proofs before expensive ZK verification
    require!(
        proof.expected_binding != [0u8; HASH_SIZE],
        CoordinationError::InvalidProofBinding
    );
    require!(
        proof.output_commitment != [0u8; HASH_SIZE],
        CoordinationError::InvalidOutputCommitment
    );

    // CRITICAL: Validate nullifier is not all zeros (fix: issue #336)
    // The nullifier prevents proof/knowledge reuse across tasks
    require!(
        proof.nullifier != [0u8; HASH_SIZE],
        CoordinationError::InvalidNullifier
    );

    // NOTE: The nullifier account is initialized via Anchor's `init` constraint.
    // If the account already exists (nullifier was already spent), Anchor will
    // automatically reject the transaction with AccountAlreadyInitialized error.
    // This prevents proof/knowledge reuse without explicit duplicate checking.

    verify_zk_proof(&proof, task.key(), worker.authority)?;

    // Initialize the nullifier account to mark it as spent
    nullifier_account.nullifier_value = proof.nullifier;
    nullifier_account.task = task.key();
    nullifier_account.agent = worker.key();
    nullifier_account.spent_at = clock.unix_timestamp;
    // bump is set automatically by Anchor's init constraint

    // Update claim fields (must be set before execute_completion_rewards)
    claim.proof_hash = proof.output_commitment;
    // Private completions don't store result data on-chain (privacy preserved)
    claim.result_data = [0u8; RESULT_DATA_SIZE];
    claim.is_completed = true;
    claim.completed_at = clock.unix_timestamp;

    // FIX: Use task-locked fee (was incorrectly using protocol_config.protocol_fee_bps)
    let protocol_fee_bps = calculate_fee_with_reputation(task.protocol_fee_bps, worker.reputation);

    // Execute reward transfer, state updates, and event emissions
    execute_completion_rewards(
        task,
        claim,
        escrow,
        worker,
        &mut ctx.accounts.protocol_config,
        &ctx.accounts.authority.to_account_info(),
        &ctx.accounts.treasury.to_account_info(),
        protocol_fee_bps,
        None, // Private: preserve privacy
        &clock,
    )?;

    // Only close escrow when task is fully completed (all required completions done).
    // For collaborative tasks with max_workers > 1, this keeps the escrow open
    // for subsequent workers to complete and receive their share.
    if task.status == TaskStatus::Completed {
        escrow.close(ctx.accounts.creator.to_account_info())?;
    }

    Ok(())
}

// ============================================================================
// ZK Proof Verification Helpers
// ============================================================================

/// Encode a pubkey as 32 separate field elements (one per byte) for the ZK witness.
/// Each byte becomes a 32-byte big-endian field element with the byte in the last position.
fn append_pubkey_as_field_elements(
    inputs: &mut [[u8; 32]; ZK_WITNESS_FIELD_COUNT],
    offset: usize,
    pubkey: &Pubkey,
) {
    for (i, byte) in pubkey.to_bytes().iter().enumerate() {
        inputs[offset + i][FIELD_SIZE - 1] = *byte;
    }
}

/// Build public inputs array for groth16-solana verification.
/// Format: 68 field elements, each 32 bytes big-endian.
fn build_public_inputs(
    task_key: &Pubkey,
    agent: &Pubkey,
    proof: &PrivateCompletionProof,
) -> [[u8; 32]; ZK_WITNESS_FIELD_COUNT] {
    let mut inputs = [[0u8; 32]; ZK_WITNESS_FIELD_COUNT];

    // Public inputs 0-31: task_id (each byte as separate field element)
    append_pubkey_as_field_elements(&mut inputs, 0, task_key);

    // Public inputs 32-63: agent_pubkey (each byte as separate field element)
    append_pubkey_as_field_elements(&mut inputs, 32, agent);

    // Public input 64: constraint_hash
    inputs[64] = proof.constraint_hash;

    // Public input 65: output_commitment
    inputs[65] = proof.output_commitment;

    // Public input 66: expected_binding
    inputs[66] = proof.expected_binding;

    // Public input 67: nullifier (prevents proof/knowledge reuse)
    inputs[67] = proof.nullifier;

    inputs
}

fn verify_zk_proof(proof: &PrivateCompletionProof, task_key: Pubkey, agent: Pubkey) -> Result<()> {
    log_compute_units("zk_verify_start");

    // Validate proof size matches expected Groth16 proof format
    require!(
        proof.proof_data.len() == ZK_EXPECTED_PROOF_SIZE,
        CoordinationError::InvalidProofSize
    );

    // Security check: block ZK proofs with development verifying key (issues #356, #358)
    // Development keys (gamma == delta) make proofs forgeable.
    // The key must be replaced via MPC ceremony before use.
    require!(
        !crate::verifying_key::is_development_key(),
        CoordinationError::DevelopmentKeyNotAllowed
    );

    let public_inputs = build_public_inputs(&task_key, &agent, proof);
    let vk = get_verifying_key();

    log_compute_units("zk_inputs_built");

    // Split proof into components: proof_a (G1), proof_b (G2), proof_c (G1)
    // Using direct slice references avoids unnecessary copies on the stack
    let proof_a: [u8; ZK_PROOF_A_SIZE] = proof.proof_data[0..ZK_PROOF_A_SIZE]
        .try_into()
        .map_err(|_| CoordinationError::InvalidProofSize)?;

    let proof_b: [u8; ZK_PROOF_B_SIZE] = proof.proof_data[ZK_PROOF_A_SIZE..ZK_PROOF_A_SIZE + ZK_PROOF_B_SIZE]
        .try_into()
        .map_err(|_| CoordinationError::InvalidProofSize)?;

    let proof_c: [u8; ZK_PROOF_C_SIZE] = proof.proof_data[ZK_PROOF_A_SIZE + ZK_PROOF_B_SIZE..]
        .try_into()
        .map_err(|_| CoordinationError::InvalidProofSize)?;

    // Verify the Groth16 proof using groth16-solana
    // This is the most CU-intensive operation (~100-130k CU for BN254 pairing)
    let mut verifier = Groth16Verifier::new(&proof_a, &proof_b, &proof_c, &public_inputs, &vk)
        .map_err(|e| {
            msg!("Failed to create Groth16 verifier: {:?}", e);
            CoordinationError::ZkVerificationFailed
        })?;

    log_compute_units("zk_verifier_created");

    verifier.verify().map_err(|e| {
        msg!("ZK proof verification failed: {:?}", e);
        CoordinationError::ZkVerificationFailed
    })?;

    log_compute_units("zk_verify_done");

    Ok(())
}
